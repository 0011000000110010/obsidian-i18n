{
  "manifest": {
    "id": "obsidian-local-images-plus",
    "author": "宇桐非",
    "version": "0.15.9",
    "pluginVersion": "0.15.9"
  },
  "description": {
    "original": "Local Images Plus plugin searches for all external media links in your notes, downloads and saves them locally and adjusts the links in your notes to point to the saved files.",
    "translation": "Local Images Plus plugin searches for all external media links in your notes, downloads and saves them locally and adjusts the links in your notes to point to the saved files."
  },
  "dict": {
    ".setName(\"Show notifications\")": ".setName(\"显示通知\")",
    ".setName(\"Disable additional commands\")": ".setName(\"禁用附加命令\")",
    ".setName(\"Automatic processing\")": ".setName(\"自动处理\")",
    ".setName(\"Automatic processing interval\")": ".setName(\"自动处理间隔\")",
    ".setName(\"Number of retries for every single attachment\")": ".setName(\"每个附件的重试次数\")",
    ".setName(\"Process all new markdown files\")": ".setName(\"处理所有新的Markdown文件\")",
    ".setName(\"Process all new attachements\")": ".setName(\"处理所有新的附件\")",
    ".setName(\"Use MD5 for new attachements\")": ".setName(\"为新附件使用MD5\")",
    ".setName(\"Download unknown filetypes\")": ".setName(\"下载未知文件类型\")",
    ".setName(\"Convert PNG to JPEG (Web Images)\")": ".setName(\"将PNG转换为JPEG（网络图片）\")",
    ".setName(\"Convert PNG to JPEG (Pasted Images)\")": ".setName(\"将PNG转换为JPEG（粘贴图片）\")",
    ".setName(\"Jpeg Quality\")": ".setName(\"JPEG质量\")",
    ".setName(\"File size lower limit in Kb\")": ".setName(\"文件大小下限（KB）\")",
    ".setName(\"Exclusions\")": ".setName(\"排除项\")",
    ".setName(\"Do not create Obsidian attachment folder (For compatibility with other plugins)\")": ".setName(\"不创建Obsidian附件文件夹（与其他插件兼容）\")",
    ".setName(\"Preserve link captions\")": ".setName(\"保留链接标题\")",
    ".setName(\"Add original filename or 'Open file' tag\")": ".setName(\"添加原始文件名或'打开文件'标签\")",
    ".setName(\"Include\")": ".setName(\"包含\")",
    ".setName(\"Remove files completely\")": ".setName(\"完全移除文件\")",
    ".setName(\"How to write paths in tags\")": ".setName(\"如何在标签中写入路径\")",
    ".setName(\"Folder to save new attachements\")": ".setName(\"保存新附件的文件夹\")",
    ".setName(\"Move/delete/rename media folder\")": ".setName(\"移动/删除/重命名媒体文件夹\")",
    ".setName(\"Media folder\")": ".setName(\"媒体文件夹\")",
    ".setName(\"Debug\")": ".setName(\"调试\")",
    ".setDesc(\"Show notifications when pages were processed.\")": ".setDesc(\"当页面处理完毕时显示通知。\")",
    ".setDesc(\"Do not show additional commands in command palette. Reload the plugin in settings to take effect (turn off/on).\")": ".setDesc(\"不在命令面板中显示附加命令。在设置中重新加载插件以生效（关闭/开启）。\")",
    ".setDesc(\"Process notes on create/copy/paste.\")": ".setDesc(\"在创建/复制/粘贴时处理笔记。\")",
    ".setDesc(\"Interval in seconds for processing update. It takes some time to reveal changed content of a note to plugins.\")": ".setDesc(\"处理更新的时间间隔（秒）。向插件显示笔记更改内容需要一些时间。\")",
    ".setDesc(\"If an error occurs during downloading (network etc.) try to re-download several times.\")": ".setDesc(\"如果下载过程中出现错误（如网络问题），尝试重新下载多次。\")",
    ".setDesc(\"Process all new created/cloud-synced files with corresponding extensions.\")": ".setDesc(\"处理所有具有相应扩展名的新创建/云同步文件。\")",
    ".setDesc(\"The plugin will also move all attachements from obsidian default folder to plugin folder.\")": ".setDesc(\"该插件还将把所有附件从Obsidian默认文件夹移动到插件文件夹。\")",
    ".setDesc(\"The plugin will use MD5 when renaming all new attachements.\")": ".setDesc(\"该插件在重命名所有新附件时将使用MD5。\")",
    ".setDesc(\"Download unknown filetypes and save them with .unknown extension.\")": ".setDesc(\"下载未知文件类型并以.unknown扩展名保存它们。\")",
    ".setDesc(\"Convert all downloaded PNG files to JPEG. May reduce file size by several times, but can also affect performance.\")": ".setDesc(\"将所有下载的PNG文件转换为JPEG。可能会使文件大小减少几倍，但也可能影响性能。\")",
    ".setDesc(\"Convert all pasted PNG files to JPEG. May reduce file size by several times, but can also affect performance.\")": ".setDesc(\"将所有粘贴的PNG文件转换为JPEG。可能会使文件大小减少几倍，但也可能影响性能。\")",
    ".setDesc(\"Jpeg quality selection (30 to 100).\")": ".setDesc(\"Jpeg质量选择（30到100）。\")",
    ".setDesc(\"Do not download files with size less than this value. Set 0 for no limit.\")": ".setDesc(\"不要下载小于这个值的文件。设置为0表示无限制。\")",
    ".setDesc(\"The plugin will not download attachements with these extensions.\")": ".setDesc(\"该插件不会下载具有这些扩展名的附件。\")",
    ".setDesc(\"The plugin will not create an Obsidian attachments folder. This may cause the plugin to behave incorrectly. \")": ".setDesc(\"该插件不会创建一个Obsidian附件文件夹。这可能导致插件行为异常。\")",
    ".setDesc(\"Add media links captions to converted tags.\")": ".setDesc(\"将媒体链接标题添加到转换后的标签。\")",
    ".setDesc(\"Add [[original filename]] or [original filename](link to attachement) after replaced tag (only for file:// protocol or dropped/pasted files ).\")": ".setDesc(\"在替换标签后添加[[原始文件名]]或[原始文件名]（链接到附件）（仅适用于file://协议或拖放/粘贴文件）。\")",
    ".setDesc(\"Include only files matching this regex pattern when running on all notes.\")": ".setDesc(\"在运行所有笔记时只包含匹配此正则表达式的文件。\")",
    ".setDesc(\"Do not move orphaned files into the garbage can.\")": ".setDesc(\"不要将孤立文件移到回收站。\")",
    ".setDesc(\"Select whether to write full paths in tags or not.\")": ".setDesc(\"选择是否在标签中写入完整路径。\")",
    ".setDesc(\"Select where all new attachements will be saved.\\nYou can use templates e.g. _resouces/${date}/${notename}\")": ".setDesc(\"选择所有新附件将保存的位置。\\n您可以使用模板例如_resouces/${date}/${notename}\")",
    ".setDesc(\"Folder to keep all downloaded media files.\")": ".setDesc(\"用于保存所有下载媒体文件的文件夹。\")",
    ".setDesc(\"Enable debug output to console.\")": ".setDesc(\"启用控制台调试输出。\")",
    ".createEl(\"a\", { text: \"Support the project! \", href: \"https://www.buymeacoffee.com/sergeikorneev\", cls: \"donheader_txt\" })": ".createEl(\"a\", { text: \"支持该项目！\", href: \"https://www.buymeacoffee.com/sergeikorneev\", cls: \"donheader_txt\" })",
    ".createEl(\"h3\", { text: \"Interface settings\" })": ".createEl(\"h3\", { text: \"界面设置\" })",
    ".createEl(\"h3\", { text: \"Processing settings\" })": ".createEl(\"h3\", { text: \"处理设置\" })",
    ".createEl(\"h3\", { text: \"Note settings\" })": ".createEl(\"h3\", { text: \"笔记设置\" })",
    ".createEl(\"h3\", { text: \"Orphaned attachments\" })": ".createEl(\"h3\", { text: \"孤立附件\" })",
    ".createEl(\"h3\", { text: \"Media folder settings\" })": ".createEl(\"h3\", { text: \"媒体文件夹设置\" })",
    ".createEl(\"h3\", { text: \"Troubleshooting\" })": ".createEl(\"h3\", { text: \"故障排除\" })",
    "name: 'GPSLatitude'": "name: 'GPS纬度'",
    "name: 'GPSLongitude'": "name: 'GPS经度'",
    "name: 'ModifyDate'": "name: '修改日期'",
    "name: 'DateTimeOriginal'": "name: '原始日期时间'",
    "name: 'CreateDate'": "name: '创建日期'",
    "name: ' + name + '": "name: ' + name + '",
    "name: \" + fileName, false);\n        if (!fileName) {\n            throw new Error(\"": "name: \" + fileName, false);\n        if (!fileName) {\n            throw new Error(\"",
    "name: \"Localize attachments for the current note (plugin folder)\"": "name: \"本地化当前笔记的附件（插件文件夹）\"",
    "name: \"Localize attachments for the current note (Obsidian folder)\"": "name: \"本地化当前笔记的附件（Obsidian文件夹）\"",
    "name: \"Set the first found # header as a note name.\"": "name: \"将找到的第一个#标题作为笔记名称。\"",
    "name: \"Localize attachments for all your notes (plugin folder)\"": "name: \"本地化所有笔记的附件（插件文件夹）\"",
    "name: \"Convert selection to URI\"": "name: \"将选择转换为URI\"",
    "name: \"Convert selection from html to markdown\"": "name: \"将选择从html转换为markdown\"",
    "name: \"Remove all orphaned attachments (Obsidian folder)\"": "name: \"移除所有孤立的附件（Obsidian文件夹）\"",
    "name: \"Remove all orphaned attachments (Plugin folder)\"": "name: \"移除所有孤立的附件（插件文件夹）\"",
    ".addOption(\"fullDirPath\", \"Full path\")": ".addOption(\"fullDirPath\", \"完整路径\")",
    ".addOption(\"onlyRelative\", \"Relative to note\")": ".addOption(\"onlyRelative\", \"相对于笔记\")",
    ".addOption(\"baseFileName\", \"Only filename\")": ".addOption(\"baseFileName\", \"仅文件名\")",
    ".addOption(\"obsFolder\", \"Copy Obsidian settings\")": ".addOption(\"obsFolder\", \"复制Obsidian设置\")",
    ".addOption(\"inFolderBelow\", \"In the root folder specified below\")": ".addOption(\"inFolderBelow\", \"在下面指定的根文件夹中\")",
    ".addOption(\"nextToNoteS\", \"Next to note in the folder specified below\")": ".addOption(\"nextToNoteS\", \"在下面指定的文件夹中紧邻笔记\")",
    "new Error('Expected an instance of stream.Readable')": "new Error('期望一个stream.Readable的实例')",
    "new Error('Stream closed')": "new Error('流已关闭')",
    "new Error('peekData should be defined')": "new Error('peekData应该被定义')",
    "new Error('`options.position` must be equal or greater than `tokenizer.position`')": "new Error('`options.position`必须等于或大于`tokenizer.position`')",
    "new Error('Cannot peek from a negative offset in a stream')": "new Error('不能从流中的负偏移量进行预览')",
    "new Error(`File not a file: ${sourceFilePath}`)": "new Error(`不是文件: ${sourceFilePath}`)",
    "new Error(\"Invalid DOCTYPE\")": "new Error(\"无效的DOCTYPE\")",
    "new Error(`Unclosed DOCTYPE`)": "new Error(`未闭合的DOCTYPE`)",
    "new Error(`Invalid Tag instead of DOCTYPE`)": "new Error(`无效的标签代替了DOCTYPE`)",
    "new Error(\"External entites are not supported\")": "new Error(\"不支持外部实体\")",
    "new Error(`Invalid entity name ${name}`)": "new Error(`无效的实体名称 ${name}`)",
    "new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`)": "new Error(`未配对的标签不能作为结束标签使用: </${tagName}>`)",
    "new Error(\"Pi Tag is not closed.\")": "new Error(\"Pi 标签没有关闭。\")",
    "new Error(`Unexpected end of ${rawTagName}`)": "new Error(`意外结束的 ${rawTagName}`)",
    "new Error(\"XML data is accepted in String or Bytes[] form.\")": "new Error(\"XML数据接受String或Bytes[]形式。\")",
    "new Error(\"Entity value can't have '&'\")": "new Error(\"实体值不能包含'&'\")",
    "new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")": "new Error(\"实体必须没有'&'和';'。例如，使用'#xD'代替'&#xD;'。\")",
    "new Error(\"An entity with value '&' is not permitted\")": "new Error(\"不允许有'&'值的实体\")",
    "new Error('Replacement string cannot contain reserved filename characters')": "new Error('替换字符串不能包含保留的文件名字符')",
    "new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')": "new Error('无法动态加载\"' + path + '\"。请适当配置@rollup/plugin-commonjs的dynamicRequireTargets或ignoreDynamicRequires选项，以便此require调用可以工作。')",
    "new Error(\"Cannot find module '\"+i+\"'\")": "new Error(\"无法找到模块 '\"+i+\"'\")",
    "new Error('Bad alphabet')": "new Error('错误的字母表')",
    "new Error('Number \"' + number + '\" contains of non-alphabetic digits (' + this.srcAlphabet + ')": "new Error('数字\"' + number + '\"包含非字母数字（' + this.srcAlphabet + '）",
    "new Error('Invalid string. Length must be a multiple of 4')": "new Error('无效的字符串。长度必须是4的倍数')",
    "new Error(\"Invalid BMP File\")": "new Error(\"无效的BMP文件\")",
    "new Error('Invalid flush value')": "new Error('无效的刷新值')",
    "new Error('invalid number of gzip magic number bytes read')": "new Error('读取的gzip魔术数字字节数无效')",
    "new Error('deflateParams Not supported')": "new Error('不支持deflateParams')",
    "new Error('Unknown mode ' + this.mode);\n\t  }\n\n\t  if (this.err !== exports.Z_OK) {\n\t    this._error('Init error')": "new Error('未知模式 ' + this.mode);\n\t  }\n\n\t  if (this.err !== exports.Z_OK) {\n\t    this._error('初始化错误')",
    "new Error('invalid input')": "new Error('输入无效')",
    "new Error('zlib binding closed')": "new Error('zlib绑定已关闭')",
    "new Error('Invalid code point')": "new Error('无效的代码点')",
    "new Error('Unhandled \"error\" event. (' + er + ')": "new Error('未处理的\"error\"事件。(' + er + ')",
    "new Error('Possible EventEmitter memory leak detected. ' +\n\t            existing.length + ' \"' + String(type) + '\" listeners ' +\n\t            'added. Use emitter.setMaxListeners() to ' +\n\t            'increase limit.')": "new Error('检测到可能的EventEmitter内存泄漏。' +\n\t            existing.length + ' \"' + String(type) + '\"监听器 ' +\n\t            '已添加。使用emitter.setMaxListeners()来 ' +\n\t            '增加限制。')",
    "new Error('Invalid EXIF header')": "new Error('无效的EXIF头部')",
    "new Error('Invalid TIFF header')": "new Error('无效的TIFF头部')",
    "new Error('Invalid TIFF data')": "new Error('无效的TIFF数据')",
    "new Error('Invalid JPEG section offset')": "new Error('无效的JPEG部分偏移量')",
    "new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')": "new Error('不支持协议\"' + params.protocol + '\"。预期\"https:\"')",
    "new Error(\"invalid ACn encoding\")": "new Error(\"无效的ACn编码\")",
    "new Error(\"marker was not found\")": "new Error(\"标记未找到\")",
    "new Error(\"SOI not found\")": "new Error(\"SOI未找到\")",
    "new Error(\"DQT: invalid table spec\")": "new Error(\"DQT: 无效的表格规格\")",
    "new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n\t        }\n\t        fileMarker = readUint16();\n\t      }\n\t      if (frames.length != 1)\n\t        throw new Error(\"only single frame JPEGs supported\")": "new Error(\"未知JPEG标记 \" + fileMarker.toString(16));\n\t        }\n\t        fileMarker = readUint16();\n\t      }\n\t      if (frames.length != 1)\n\t        throw new Error(\"仅支持单帧JPEG\")",
    "new Error(\"Unsupported amount of components\")": "new Error(\"不支持的组件数量\")",
    "new Error(\"JPX Error: Invalid box field size\")": "new Error(\"JPX错误：无效的盒子字段大小\")",
    "new Error(\"JPX Error: No size marker found in JPX stream\")": "new Error(\"JPX错误：JPX流中未找到尺寸标记\")",
    "new Error(\"JPX Error: Unsupported COD options (\" + unsupported.join(\", \")": "new Error(\"JPX错误：不支持的COD选项 (\" + unsupported.join(\", \")",
    "new Error(\"JPX Error: Codestream code 0xFF53 (COC) is \" + \"not implemented\")": "new Error(\"JPX错误：码流代码0xFF53 (COC)未实现\")",
    "new Error(\"JPX Error: Out of packets\")": "new Error(\"JPX错误：超出包范围\")",
    "new Error('http status code: '+res.statusCode))\n\t    if (!body)\n\t      return cb(new Error('no body result')": "new Error('http状态码: '+res.statusCode))\n\t    if (!body)\n\t      return cb(new Error('没有正文结果')",
    "new Error('your browser does not support XHR loading')": "new Error('您的浏览器不支持XHR加载')",
    "new Error(\"Width/Height invalid.\")": "new Error(\"宽度/高度无效。\")",
    "new Error(\"Background index out of range.\")": "new Error(\"背景索引超出范围。\")",
    "new Error(\"Background index explicitly passed as 0.\")": "new Error(\"背景索引明确地传递为0。\")",
    "new Error(\"Loop count invalid.\")": "new Error(\"循环计数无效。\")",
    "new Error(\"x/y invalid.\")": "new Error(\"x/y无效。\")",
    "new Error(\"Not enough pixels for the frame size.\")": "new Error(\"帧大小所需的像素不足。\")",
    "new Error(\"Must supply either a local or global palette.\")": "new Error(\"必须提供局部或全局调色板。\")",
    "new Error(\"Disposal out of range.\")": "new Error(\"清除超出范围。\")",
    "new Error(\"Transparent color index.\")": "new Error(\"透明颜色索引。\")",
    "new Error(\"Invalid GIF 87a/89a header.\")": "new Error(\"无效的GIF 87a/89a头。\")",
    "new Error(\"Invalid graphics extension block.\")": "new Error(\"无效的图形扩展块。\")",
    "new Error(\"slide too late\")": "new Error(\"幻灯片太晚\")",
    "new Error(\"block gone\")": "new Error(\"块已消失\")",
    "new Error(\"bug2\")": "new Error(\"bug2\")",
    "new Error('no data provided')": "new Error('未提供数据')",
    "new Error('no data in BMFont file')": "new Error('BMFont文件中无数据')",
    "new Error('malformed file at line ' + i + ' -- needs page id=N')": "new Error('第' + i + '行的文件格式错误 -- 需要页面id=N')",
    "new Error('malformed file at line ' + i + ' -- needs page file=\"path\"')": "new Error('第' + i + '行的文件格式错误 -- 需要页面file=\"path\"')",
    "new Error('invalid buffer length for BMFont')": "new Error('BMFont的缓冲区长度无效')",
    "new Error('BMFont missing BMF byte header')": "new Error('BMFont缺少BMF字节头')",
    "new Error('Only supports BMFont Binary v3 (BMFont App v1.10)')": "new Error('仅支持BMFont Binary v3 (BMFont App v1.10)')",
    "new Error('malformed file -- no <pages> element')": "new Error('文件格式错误 -- 没有<pages>元素')",
    "new Error('malformed file -- page \"id\" attribute is NaN')": "new Error('文件格式错误 -- 页面\"id\"属性为NaN')",
    "new Error('malformed file -- needs page \"file\" attribute')": "new Error('文件格式错误 -- 需要页面\"file\"属性')",
    "new Error('Missing url option from options for request method.')": "new Error('请求方法的选项中缺少url选项。')",
    "new Error('phin \\'form\\' option must be of type Object if present.')": "new Error('如果存在，phin \\'form\\' 选项必须是Object类型。')",
    "new Error('Invalid / unknown URL protocol. Expected HTTP or HTTPS.')": "new Error('无效或未知的URL协议。预期HTTP或HTTPS。')",
    "new Error('Timeout has been reached.')": "new Error('超时已到达。')",
    "new Error('Couldn\\'t stringify object. (Likely due to a circular reference.)')": "new Error('无法序列化对象。(可能是由于循环引用。)')",
    "new Error('Ran out of data')": "new Error('数据耗尽')",
    "new Error('unrecognised depth')": "new Error('未识别的深度')",
    "new Error('extra data found')": "new Error('发现多余的数据')",
    "new Error('input color type:' + options.inputColorType + ' is not supported at present')": "new Error('输入颜色类型:' + options.inputColorType + '目前不支持')",
    "new Error('Stream not writable')": "new Error('流不可写')",
    "new Error('There are some read requests waiting on finished stream')": "new Error('有一些读请求正在已完成的流上等待')",
    "new Error('unrecognised filter types')": "new Error('未识别的过滤器类型')",
    "new Error('To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0')": "new Error('要在旧版本的Node.js中使用此库的同步功能，请将pngjs固定到v2.3.0')",
    "new Error('bad png - invalid compressed data response')": "new Error('损坏的png - 无效的压缩数据响应')",
    "new Error('option color type:' + options.colorType + ' is not supported at present')": "new Error('选项颜色类型:' + options.colorType + '目前不支持')",
    "new Error('option input color type:' + options.inputColorType + ' is not supported at present')": "new Error('选项输入颜色类型:' + options.inputColorType + '目前不支持')",
    "new Error('option bit depth:' + options.bitDepth + ' is not supported at present')": "new Error('选项位深度:' + options.bitDepth + '目前不支持')",
    "new Error('bad png - invalid inflate data response')": "new Error('损坏的png - 无效的解压数据响应')",
    "new Error('Invalid file signature')": "new Error('无效的文件签名')",
    "new Error('Expected IHDR on beggining')": "new Error('期望在开始处有IHDR')",
    "new Error('Unsupported compression method')": "new Error('不支持的压缩方法')",
    "new Error('Unsupported filter method')": "new Error('不支持的过滤方法')",
    "new Error('Unsupported interlace method')": "new Error('不支持的交织方法')",
    "new Error('Transparency chunk must be after palette')": "new Error('透明度块必须在调色板之后')",
    "new Error('More transparent colors than palette size')": "new Error('比调色板大小更多的透明颜色')",
    "new Error('Expected palette not found')": "new Error('未找到期望的调色板')",
    "new Error('bitblt reading outside image')": "new Error('bitblt读取图像之外的数据')",
    "new Error('bitblt writing outside image')": "new Error('bitblt写入图像之外的数据')",
    "new Error('There are some read requests waitng on finished stream')": "new Error('有一些读请求正在已完成的流上等待')",
    "new Error('unrecognised content at end of stream')": "new Error('流末尾处的未识别内容')",
    "new Error('setTimeout has not been defined')": "new Error('setTimeout尚未定义')",
    "new Error('clearTimeout has not been defined')": "new Error('clearTimeout尚未定义')",
    "new Error('process.binding is not supported')": "new Error('不支持process.binding')",
    "new Error('process.chdir is not supported')": "new Error('不支持process.chdir')",
    "new Error('stream.unshift() after end event')": "new Error('在结束事件后调用stream.unshift()')",
    "new Error('stream.push() after EOF')": "new Error('在EOF后调用stream.push()')",
    "new Error('_read() is not implemented')": "new Error('_read()尚未实现')",
    "new Error('\"endReadable()\" called on non-empty stream')": "new Error('\"endReadable()\" 被调用于非空流')",
    "new Error('write callback called multiple times')": "new Error('write回调被多次调用')",
    "new Error('_transform() is not implemented')": "new Error('_transform()尚未实现')",
    "new Error('Calling transform done when ws.length != 0')": "new Error('在ws.length != 0时调用transform完成')",
    "new Error('Calling transform done when still transforming')": "new Error('仍在转换时调用transform完成')",
    "new Error('Cannot pipe, not readable')": "new Error('无法管道传输，不是可读的')",
    "new Error('write after end')": "new Error('在结束之后写入')",
    "new Error('_write() is not implemented')": "new Error('_write()尚未实现')",
    "new Error('Invalid value for opts.mode')": "new Error('opts.mode的有效值无效')",
    "new Error('XHR error')": "new Error('XHR错误')",
    "new Error('Argument must be a Buffer')": "new Error('参数必须是Buffer')",
    "new Error(\"callback argument missing\")": "new Error(\"缺少回调参数\")",
    "new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\")": "new Error(\"\" + (evt || \"未知的XMLHttpRequest错误\")",
    "new Error(\"Internal XMLHttpRequest Error\")": "new Error(\"内部XMLHttpRequest错误\")",
    "new Error(\"XMLHttpRequest timeout\")": "new Error(\"XMLHttpRequest超时\")",
    "new Error(\"Headers cannot be set on an XDomainRequest object\")": "new Error(\"不能在一个XDomainRequest对象上设置头部\")",
    "new Error('Buffer length is incorrect')": "new Error('缓冲区长度不正确')",
    "new Error('Cant access the filesystem. You can use the getBase64 method.')": "new Error('无法访问文件系统。您可以使用getBase64方法。')",
    "new Error('Could not find MIME for Buffer <' + path + '>')": "new Error('无法为Buffer <' + path + '> 找到MIME类型')",
    "new Error('Invalid settings specified for the resizer.')": "new Error('为调整器指定的设置无效。')",
    "new Error('Native crypto module could not be used to get secure random number.')": "new Error('无法使用原生crypto模块来获取安全随机数。')",
    "new Error('Malformed UTF-8 data')": "new Error('格式错误的UTF-8数据')",
    "new Error('Tokenizer instance wasn\\'t specified.')": "new Error('未指定Tokenizer实例。')",
    "new Error('Node of type ' + this.node.type + ' doesn\\'t have \"' + property + '\" collection.')": "new Error('类型为 ' + this.node.type + ' 的节点没有 \"' + property + '\" 集合。')",
    "new Error('Unknown compat-transform: ' + transformName + '. ' + 'Available transforms are: ' + Object.keys(compatTransforms).join(', ')": "new Error('未知的兼容转换: ' + transformName + '. 可用的转换有: ' + Object.keys(compatTransforms).join(', ')",
    "new Error('Unknown optimization-transform: ' + transformName + '. ' + 'Available transforms are: ' + Array.from(optimizationTransforms.keys()).join(', ')": "new Error('未知的优化转换: ' + transformName + '. 可用的转换有: ' + Array.from(optimizationTransforms.keys()).join(', ')",
    "new Error('NFA/DFA: Flags are not supported yet.')": "new Error('NFA/DFA: 尚不支持标志。')",
    "new Error('Unknown repeatition: ' + node.quantifier.kind + '.')": "new Error('未知的重复: ' + node.quantifier.kind + '.')",
    "new Error('NFA/DFA: Only simple chars are supported yet.')": "new Error('NFA/DFA: 目前只支持简单字符。')",
    "new Error('You must pass a function to execute')": "new Error('您必须传递一个函数来执行')",
    "new Error(\"Failed to generate file name for media file.\")": "new Error(\"生成媒体文件名失败。\")",
    "new TypeError(`Expected the \\`input\\` argument to be of type \\`Uint8Array\\` or \\`Buffer\\` or \\`ArrayBuffer\\`, got \\`${typeof input}\\``)": "new TypeError(`期望 \\`input\\` 参数为 \\`Uint8Array\\` 或 \\`Buffer\\` 或 \\`ArrayBuffer\\` 类型，实际得到 \\`${typeof input}\\` 类型`)",
    "new TypeError('Expected a string')": "new TypeError('期望字符串')",
    "new TypeError('\"block\" argument must be a function')": "new TypeError('\"block\" 参数必须是一个函数')",
    "new TypeError('Bad argument')": "new TypeError('参数错误')",
    "new TypeError('Not a string or buffer')": "new TypeError('不是字符串或缓冲区')",
    "new TypeError('Invalid strategy: ' + strategy);\n\t  }\n\n\t  if (this._level !== level || this._strategy !== strategy) {\n\t    var self = this;\n\t    this.flush(binding.Z_SYNC_FLUSH, function () {\n\t      assert(self._handle, 'zlib binding closed')": "new TypeError('无效策略: ' + strategy);\n\t  }\n\n\t  if (this._level !== level || this._strategy !== strategy) {\n\t    var self = this;\n\t    this.flush(binding.Z_SYNC_FLUSH, function () {\n\t      assert(self._handle, 'zlib绑定关闭')",
    "new TypeError('\"size\" argument must be of type number')": "new TypeError('\"size\" 参数必须是数字类型')",
    "new TypeError('\"list\" argument must be an Array of Buffers')": "new TypeError('\"list\" 参数必须是Buffer数组')",
    "new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '')": "new TypeError('未知编码: ' + encoding)\n\t        encoding = (encoding + '')",
    "new TypeError('Argument must be a Buffer')": "new TypeError('参数必须是Buffer')",
    "new TypeError('val must be string, number or Buffer')": "new TypeError('val 必须是字符串、数字或Buffer')",
    "new TypeError('\"buffer\" argument must be a Buffer instance')": "new TypeError('\"buffer\" 参数必须是Buffer实例')",
    "new TypeError('argument should be a Buffer')": "new TypeError('参数应该是Buffer')",
    "new TypeError('encoding must be a string')": "new TypeError('编码必须是字符串')",
    "new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0);\n\t      if ((encoding === 'utf8' && code < 128) ||\n\t          encoding === 'latin1')": "new TypeError('未知编码: ' + encoding)\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0);\n\t      if ((encoding === 'utf8' && code < 128) ||\n\t          encoding === 'latin1')",
    "new TypeError('The value \"' + val +\n\t        '\" is invalid for argument \"value\"')": "new TypeError('值 \"' + val +\n\t        '\" 对于参数 \"value\" 是无效的')",
    "new TypeError('\"defaultMaxListeners\" must be a positive number')": "new TypeError('\"defaultMaxListeners\" 必须是正数')",
    "new TypeError('\"n\" argument must be a positive number')": "new TypeError('\"n\" 参数必须是正数')",
    "new TypeError('\"listener\" argument must be a function')": "new TypeError('\"listener\" 参数必须是函数')",
    "new TypeError(\"Invalid attempt to spread non-iterable instance\")": "new TypeError(\"尝试展开非可迭代实例无效\")",
    "new TypeError('iterator must be a function')": "new TypeError('iterator 必须是函数')",
    "new TypeError('Arguments to path.resolve must be strings')": "new TypeError('path.resolve的参数必须是字符串')",
    "new TypeError('Arguments to path.join must be strings')": "new TypeError('path.join的参数必须是字符串')",
    "new TypeError('\"callback\" argument must be a function')": "new TypeError('\"callback\" 参数必须是函数')",
    "new TypeError('Invalid non-string/buffer chunk')": "new TypeError('无效的非字符串/缓冲区块')",
    "new TypeError('May not write null values to stream')": "new TypeError('不能向流中写入null值')",
    "new TypeError('Unknown encoding: ' + encoding);\n\t  this._writableState.defaultEncoding = encoding;\n\t  return this;\n\t};\n\n\tfunction decodeChunk(state, chunk, encoding) {\n\t  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string')": "new TypeError('未知编码: ' + encoding);\n\t  this._writableState.defaultEncoding = encoding;\n\t  return this;\n\t};\n\n\tfunction decodeChunk(state, chunk, encoding) {\n\t  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string')",
    "new TypeError(\"Cannot call a class as a function\")": "new TypeError(\"不能将类作为函数调用\")",
    "new TypeError('Argument must not be a number')": "new TypeError('参数不能是数字')",
    "new TypeError('Argument must be a number')": "new TypeError('参数必须是数字')",
    "new TypeError(\"Invalid attempt to destructure non-iterable instance\")": "new TypeError(\"尝试解构非可迭代实例无效\")",
    "new TypeError(\"Super expression must either be null or a function\")": "new TypeError(\"Super表达式必须是null或者是一个函数\")",
    "new TypeError('Callback must be a function')": "new TypeError('回调必须是函数')",
    "new TypeError('Unknown Assertion kind: ' + node.kind);\n    }\n  },\n  CharacterClass: function CharacterClass(node) {\n    var expressions = node.expressions.map(gen$1).join('')": "new TypeError('未知断言类型: ' + node.kind);\n    }\n  },\n  CharacterClass: function CharacterClass(node) {\n    var expressions = node.expressions.map(gen$1).join('')",
    "new TypeError('Expected \"Disjunction\" node, got \"' + node.type + '\"')": "new TypeError('期望 \"Disjunction\" 节点，实际得到 \"' + node.type + '\"')",
    "msg = \"Invalid space after '<'.\";": "msg = \"'<之后的空格无效。\";",
    "msg = \"Tag '\"+tagName+\"' is an invalid name.\";": "msg = \"标签 '\"+tagName+\"' 名称无效。\";",
    "msg = 'invalid distance too far back';": "msg = '距离太远，无效';",
    "msg = 'invalid distance code';": "msg = '无效的距离代码';",
    "msg = 'invalid literal/length code';": "msg = '无效的文字/长度代码';",
    "msg = 'incorrect header check';": "msg = '头校验错误';",
    "msg = 'unknown compression method';": "msg = '未知的压缩方法';",
    "msg = 'invalid window size';": "msg = '窗口大小无效';",
    "msg = 'unknown header flags set';": "msg = '未知的头标志已设置';",
    "msg = 'header crc mismatch';": "msg = '头CRC不匹配';",
    "msg = 'invalid block type';": "msg = '块类型无效';",
    "msg = 'invalid stored block lengths';": "msg = '存储的块长度无效';",
    "msg = 'too many length or distance symbols';": "msg = '长度或距离符号过多';",
    "msg = 'invalid code lengths set';": "msg = '代码长度设置无效';",
    "msg = 'invalid bit length repeat';": "msg = '位长度重复无效';",
    "msg = 'invalid code -- missing end-of-block';": "msg = '代码无效 -- 缺少块结束';",
    "msg = 'invalid literal/lengths set';": "msg = '文字/长度设置无效';",
    "msg = 'invalid distances set';": "msg = '距离设置无效';",
    "msg = 'incorrect data check';": "msg = '数据校验错误';",
    "msg = 'incorrect length check';": "msg = '长度校验错误';",
    "msg = 'Could not load Buffer from <' + src + '> ' + '(HTTP: ' + response.statusCode + ')';": "msg = '无法从 <' + src + '> 加载 Buffer ' + '(HTTP: ' + response.statusCode + ')';",
    "msg = \"were deleted completely.\";": "msg = \"已被完全删除。\";",
    "msg = \"were moved to the system garbage can.\";": "msg = \"已被移至系统回收站。\";",
    "msg = \"were moved to the Obsidian garbage can.\";": "msg = \"已被移至Obsidian回收站。\";",
    "logError(`LocalImagesPlus: error: ${error}`, false)": "logError(`LocalImagesPlus: 错误: ${error}`, false)",
    "logError(\"Cannot generate md5: \" + e, false)": "logError(\"无法生成md5: \" + e, false)",
    "logError(\"replaceAsync: \\r\\nstr: \" + str + \"\\r\\nregex: \")": "logError(\"replaceAsync: \\r\\nstr: \" + str + \"\\r\\nregex: \")",
    "logError(\"cur regex:  \" + element)": "logError(\"当前正则表达式:  \" + element)",
    "logError(\"match: \")": "logError(\"匹配: \")",
    "logError(\"repl: \" + replp +\n                    \"\\r\\nahc: \" + anchor +\n                    \"\\r\\nlink: \" + link +\n                    \"\\r\\ncaption: \" + caption)": "logError(\"替换: \" + replp +\n                    \"\\r\\nahc: \" + anchor +\n                    \"\\r\\n链接: \" + link +\n                    \"\\r\\n标题: \" + caption)",
    "logError(\"el: \" + element[0] + \"  el2: \" + element[1] + element[2])": "logError(\"元素: \" + element[0] + \"  元素2: \" + element[1] + element[2])",
    "logError(\"IsUrl: \" + link, false)": "logError(\"是否为URL: \" + link, false)",
    "logError(\"Cannot convert to jpeg: \" + e, false)": "logError(\"无法转换为jpeg: \" + e, false)",
    "logError(\"base64ToBuff: \\r\\n\", false)": "logError(\"base64转缓冲区: \\r\\n\", false)",
    "logError(\"Cannot read base64: \" + e, false)": "logError(\"无法读取base64: \" + e, false)",
    "logError(\"Cannot read the file: \" + e, false)": "logError(\"无法读取文件: \" + e, false)",
    "logError(\"readFromDisk: \" + file, false)": "logError(\"从磁盘读取: \" + file, false)",
    "logError(\"Downloading: \" + url, false)": "logError(\"下载: \" + url, false)",
    "logError(\"Cannot download the file: \" + e, false)": "logError(\"无法下载文件: \" + e, false)",
    "logError(\"processImageTag: \" + match)": "logError(\"处理图片标签: \" + match)",
    "logError(\"ReadBase64: \\r\\n\" + fpath, false)": "logError(\"读取Base64: \\r\\n\" + fpath, false)",
    "logError(\"Readlocal: \\r\\n\" + fpath, false)": "logError(\"读取本地: \\r\\n\" + fpath, false)",
    "logError(\"\\r\\n\\nDownloading (try)": "logError(\"\\r\\n\\n下载（尝试)",
    "logError(\"Cannot get an attachment content!\", fileDatafalse)": "logError(\"无法获取附件内容！\", fileDatafalse)",
    "logError(\"Lower limit of the file size!\", false)": "logError(\"文件大小低于限制！\", false)",
    "logError(\"Image processing failed: \" + error, false)": "logError(\"图像处理失败: \" + error, false)",
    "logError(\"file: \" + link + \" content: \" + contentData + \" file ext: \" + fileExt, false)": "logError(\"文件: \" + link + \" 内容: \" + contentData + \" 文件扩展名: \" + fileExt, false)",
    "logError(\"File name: \" + fileName, false)": "logError(\"文件名: \" + fileName, false)",
    "logError(\"processactive\")": "logError(\"进程活动\")",
    "logError(\"Cannot find \" + el.link + \" skipping...\")": "logError(\"找不到 \" + el.link + \" 跳过...\")",
    "logError(\"oldbindata\")": "logError(\"旧二进制数据\")",
    "logError(\"oldext\")": "logError(\"旧扩展名\")",
    "logError(\"converting to Jpeg\")": "logError(\"转换为Jpeg\")",
    "logError(\"Deleting duplicate file: \" + oldpath)": "logError(\"删除重复文件: \" + oldpath)",
    "logError(\"Renaming existing: \" + oldpath)": "logError(\"重命名现有: \" + oldpath)",
    "logError(`renaming  ${oldpath}  to  ${newpath}`)": "logError(`重命名  ${oldpath}  到  ${newpath}`)",
    "logError(\"New file created: \")": "logError(\"新文件创建: \")",
    "logError(\"File modified: \\r\\n\")": "logError(\"文件修改: \\r\\n\")",
    "logError(\"file created  \")": "logError(\"文件创建  \")",
    "logError(\" unloaded.\")": "logError(\"卸载.\")",
    "showBalloon(`LocalImagesPlus: Error while handling file ${file.name}, ${error.toString()`": "showBalloon(`LocalImagesPlus: 在处理文件 ${file.name} 时出错, ${error.toString()`",
    "showBalloon(`Please select a note or click inside selected note in canvas.`, this.settings.showNotifications)": "showBalloon(`请选择一个笔记或点击画布中选定的笔记。`, this.settings.showNotifications)",
    "showBalloon(\"This command requires the settings 'Next to note in the folder specified below' and pattern '${notename}' at the end to be enabled, also the path cannot contain ${date} pattern.\\nPlease, change settings first!\\r\\n\", this.settings.showNotifications)": "showBalloon(\"此命令需要启用设置 '在下面指定文件夹中的笔记旁边' 并且路径末尾有模式 '${notename}'，同时路径不能包含 ${date} 模式。\\n请先更改设置！\\r\\n\", this.settings.showNotifications)",
    "showBalloon(\"Please, select a note or click inside a note in canvas!\", this.settings.showNotifications)": "showBalloon(\"请选择一个笔记或点击画布中的笔记！\", this.settings.showNotifications)",
    "showBalloon(\"The attachment folder \" + oldRootdir + \" does not exist!\", this.settings.showNotifications)": "showBalloon(\"附件文件夹 \" + oldRootdir + \" 不存在！\", this.settings.showNotifications)",
    "showBalloon(\"No orphaned files found!\", this.settings.showNotifications)": "showBalloon(\"未找到孤立文件！\", this.settings.showNotifications)",
    "showBalloon(\"This command cannot run on vault's root or on subfolder next to note!\\nPlease, change settings first!\\r\\n\", this.settings.showNotifications)": "showBalloon(\"此命令不能在仓库根目录或笔记旁边的子目录上运行！\\n请先更改设置！\\r\\n\", this.settings.showNotifications)",
    "showBalloon(\"You obsidian media folder set to '\" + obsmdir + \"', and has been created by the plugin. Please, try again. \", this.settings.showNotifications)": "showBalloon(\"您的 Obsidian 媒体文件夹设置为 '\" + obsmdir + \"'，并且是由插件创建的。请再试一次。\", this.settings.showNotifications)",
    "showBalloon(`The note was renamed to ` + fullPath, this.settings.showNotifications)": "showBalloon(`笔记已重命名为 ` + fullPath, this.settings.showNotifications)",
    "showBalloon(`Cannot rename.`, this.settings.showNotifications)": "showBalloon(`无法重命名。`, this.settings.showNotifications)",
    "showBalloon(\"Attachment folder \" + rootdir + \" was moved to trash can.\", this.settings.showNotifications)": "showBalloon(\"附件文件夹 \" + rootdir + \" 已移动到回收站。\", this.settings.showNotifications)",
    "showBalloon(\"Attachment folder was renamed to \" + newRootDir_, this.settings.showNotifications)": "showBalloon(\"附件文件夹已重命名为 \" + newRootDir_, this.settings.showNotifications)",
    "showBalloon(\"Cannot move attachment folder: \\r\\n\" + e, this.settings.showNotifications)": "showBalloon(\"无法移动附件文件夹: \\r\\n\" + e, this.settings.showNotifications)",
    "showBalloon(\"Cannot get current note! \", this.settings.showNotifications)": "showBalloon(\"无法获取当前笔记！\", this.settings.showNotifications)",
    "showBalloon(`Attachements for \"${file.path}\" were processed.`, this.settings.showNotifications)": "showBalloon(`\"${file.path}\" 的附件已被处理。`, this.settings.showNotifications)",
    "showBalloon(`WARNING!\\r\\nAttachements for \"${file.path}\" were processed, but some attachements were not downloaded/replaced...`, this.settings.showNotifications)": "showBalloon(`警告！\\r\\n\"${file.path}\" 的附件已被处理，但有些附件未被下载/替换...`, this.settings.showNotifications)",
    "showBalloon(`Page \"${file.path}\" has been processed, but nothing was changed.`, this.settings.showNotifications)": "showBalloon(`页面 \"${file.path}\" 已被处理，但没有任何改变。`, this.settings.showNotifications)",
    "showBalloon(\"Media links were found, processing...\", this.settings.showNotifications)": "showBalloon(\"发现了媒体链接，正在处理...\", this.settings.showNotifications)",
    "showBalloon(itemcount + \" attachements for note \" + note.path + \" were processed.\"": "showBalloon(itemcount + \"个附件以处理，笔记路径为: \" + note.path + \".\""
  }
}